/* Canvas.c generated by valac 0.56.17, the Vala compiler
 * generated from Canvas.vala, do not modify */

/*
 * Copyright 2024 elementary, Inc. (https://elementary.io)
 * SPDX-License-Identifier: LGPL-2.0-or-later
 */

#include "gala.h"
#include <glib.h>
#include <float.h>
#include <math.h>
#include <cogl/cogl.h>
#include <clutter/clutter.h>
#include <cairo-gobject.h>
#include <glib-object.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

enum  {
	GALA_DRAWING_CANVAS_0_PROPERTY,
	GALA_DRAWING_CANVAS_NUM_PROPERTIES
};
static GParamSpec* gala_drawing_canvas_properties[GALA_DRAWING_CANVAS_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _clutter_paint_node_unref0(var) ((var == NULL) ? NULL : (var = (clutter_paint_node_unref (var), NULL)))
enum  {
	GALA_DRAWING_CANVAS_DRAW_SIGNAL,
	GALA_DRAWING_CANVAS_NUM_SIGNALS
};
static guint gala_drawing_canvas_signals[GALA_DRAWING_CANVAS_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GalaDrawingCanvasPrivate {
	gint width;
	gint height;
	gfloat scale_factor;
	CoglTexture* texture;
	CoglBitmap* bitmap;
	gboolean dirty;
};

static gint GalaDrawingCanvas_private_offset;
static gpointer gala_drawing_canvas_parent_class = NULL;
static ClutterContentInterface * gala_drawing_canvas_clutter_content_parent_iface = NULL;

static void gala_drawing_canvas_emit_draw (GalaDrawingCanvas* self);
static gboolean gala_drawing_canvas_real_get_preferred_size (ClutterContent* base,
                                                      gfloat* out_width,
                                                      gfloat* out_height);
static void gala_drawing_canvas_real_invalidate (ClutterContent* base);
static void gala_drawing_canvas_real_invalidate_size (ClutterContent* base);
static void gala_drawing_canvas_real_paint_content (ClutterContent* base,
                                             ClutterActor* actor,
                                             ClutterPaintNode* root,
                                             ClutterPaintContext* paint_context);
static void g_cclosure_user_marshal_VOID__BOXED_INT_INT (GClosure * closure,
                                                  GValue * return_value,
                                                  guint n_param_values,
                                                  const GValue * param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);
static void gala_drawing_canvas_finalize (GObject * obj);
static GType gala_drawing_canvas_get_type_once (void);

static inline gpointer
gala_drawing_canvas_get_instance_private (GalaDrawingCanvas* self)
{
	return G_STRUCT_MEMBER_P (self, GalaDrawingCanvas_private_offset);
}

static void
gala_drawing_canvas_emit_draw (GalaDrawingCanvas* self)
{
	gint real_width = 0;
	gint real_height = 0;
	CoglBitmap* _tmp0_;
	CoglBuffer* buffer = NULL;
	CoglBitmap* _tmp5_;
	CoglBuffer* _tmp6_;
	CoglBuffer* _tmp7_;
	CoglBuffer* _tmp8_;
	void* data = NULL;
	CoglBuffer* _tmp9_;
	void* _tmp10_;
	cairo_surface_t* surface = NULL;
	gboolean mapped_buffer = FALSE;
	void* _tmp11_;
	cairo_surface_t* _tmp16_;
	cairo_t* cr = NULL;
	cairo_surface_t* _tmp17_;
	cairo_t* _tmp18_;
	cairo_t* _tmp19_;
	cairo_t* _tmp20_;
#line 19 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (self != NULL);
#line 19 "../lib/Drawing/Canvas.vala"
	_vala_return_if_fail ((self->priv->width > 0) && (self->priv->height > 0), "width > 0 && height > 0");
#line 20 "../lib/Drawing/Canvas.vala"
	self->priv->dirty = TRUE;
#line 21 "../lib/Drawing/Canvas.vala"
	real_width = (gint) ceilf (self->priv->width * self->priv->scale_factor);
#line 22 "../lib/Drawing/Canvas.vala"
	real_height = (gint) ceilf (self->priv->height * self->priv->scale_factor);
#line 23 "../lib/Drawing/Canvas.vala"
	_tmp0_ = self->priv->bitmap;
#line 23 "../lib/Drawing/Canvas.vala"
	if (_tmp0_ == NULL) {
#line 122 "Canvas.c"
		CoglContext* ctx = NULL;
		ClutterBackend* _tmp1_;
		CoglContext* _tmp2_;
		CoglContext* _tmp3_;
		CoglBitmap* _tmp4_;
#line 24 "../lib/Drawing/Canvas.vala"
		_tmp1_ = clutter_get_default_backend ();
#line 24 "../lib/Drawing/Canvas.vala"
		_tmp2_ = clutter_backend_get_cogl_context (_tmp1_);
#line 24 "../lib/Drawing/Canvas.vala"
		ctx = _tmp2_;
#line 25 "../lib/Drawing/Canvas.vala"
		_tmp3_ = ctx;
#line 25 "../lib/Drawing/Canvas.vala"
		_tmp4_ = cogl_bitmap_new_with_size (_tmp3_, (guint) real_width, (guint) real_height, COGL_PIXEL_FORMAT_CAIRO_ARGB32_COMPAT);
#line 25 "../lib/Drawing/Canvas.vala"
		_g_object_unref0 (self->priv->bitmap);
#line 25 "../lib/Drawing/Canvas.vala"
		self->priv->bitmap = _tmp4_;
#line 142 "Canvas.c"
	}
#line 28 "../lib/Drawing/Canvas.vala"
	_tmp5_ = self->priv->bitmap;
#line 28 "../lib/Drawing/Canvas.vala"
	_tmp6_ = cogl_bitmap_get_buffer (_tmp5_);
#line 28 "../lib/Drawing/Canvas.vala"
	buffer = _tmp6_;
#line 29 "../lib/Drawing/Canvas.vala"
	_tmp7_ = buffer;
#line 29 "../lib/Drawing/Canvas.vala"
	if (_tmp7_ == NULL) {
#line 30 "../lib/Drawing/Canvas.vala"
		return;
#line 156 "Canvas.c"
	}
#line 33 "../lib/Drawing/Canvas.vala"
	_tmp8_ = buffer;
#line 33 "../lib/Drawing/Canvas.vala"
	cogl_buffer_set_update_hint (_tmp8_, COGL_BUFFER_UPDATE_HINT_DYNAMIC);
#line 34 "../lib/Drawing/Canvas.vala"
	_tmp9_ = buffer;
#line 34 "../lib/Drawing/Canvas.vala"
	_tmp10_ = cogl_buffer_map (_tmp9_, COGL_BUFFER_ACCESS_READ_WRITE, COGL_BUFFER_MAP_HINT_DISCARD);
#line 34 "../lib/Drawing/Canvas.vala"
	data = _tmp10_;
#line 37 "../lib/Drawing/Canvas.vala"
	_tmp11_ = data;
#line 37 "../lib/Drawing/Canvas.vala"
	if (_tmp11_ != NULL) {
#line 172 "Canvas.c"
		gint bitmap_stride = 0;
		CoglBitmap* _tmp12_;
		void* _tmp13_;
		cairo_surface_t* _tmp14_;
#line 38 "../lib/Drawing/Canvas.vala"
		_tmp12_ = self->priv->bitmap;
#line 38 "../lib/Drawing/Canvas.vala"
		bitmap_stride = cogl_bitmap_get_rowstride (_tmp12_);
#line 39 "../lib/Drawing/Canvas.vala"
		_tmp13_ = data;
#line 39 "../lib/Drawing/Canvas.vala"
		_tmp14_ = cairo_image_surface_create_for_data ((guchar*) _tmp13_, CAIRO_FORMAT_ARGB32, real_width, real_height, bitmap_stride);
#line 39 "../lib/Drawing/Canvas.vala"
		_cairo_surface_destroy0 (surface);
#line 39 "../lib/Drawing/Canvas.vala"
		surface = _tmp14_;
#line 40 "../lib/Drawing/Canvas.vala"
		mapped_buffer = TRUE;
#line 191 "Canvas.c"
	} else {
		cairo_surface_t* _tmp15_;
#line 42 "../lib/Drawing/Canvas.vala"
		_tmp15_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, real_width, real_height);
#line 42 "../lib/Drawing/Canvas.vala"
		_cairo_surface_destroy0 (surface);
#line 42 "../lib/Drawing/Canvas.vala"
		surface = _tmp15_;
#line 43 "../lib/Drawing/Canvas.vala"
		mapped_buffer = FALSE;
#line 202 "Canvas.c"
	}
#line 46 "../lib/Drawing/Canvas.vala"
	_tmp16_ = surface;
#line 46 "../lib/Drawing/Canvas.vala"
	cairo_surface_set_device_scale (_tmp16_, (gdouble) self->priv->scale_factor, (gdouble) self->priv->scale_factor);
#line 47 "../lib/Drawing/Canvas.vala"
	_tmp17_ = surface;
#line 47 "../lib/Drawing/Canvas.vala"
	_tmp18_ = cairo_create (_tmp17_);
#line 47 "../lib/Drawing/Canvas.vala"
	cr = _tmp18_;
#line 48 "../lib/Drawing/Canvas.vala"
	_tmp19_ = cr;
#line 48 "../lib/Drawing/Canvas.vala"
	cr = NULL;
#line 48 "../lib/Drawing/Canvas.vala"
	_tmp20_ = _tmp19_;
#line 48 "../lib/Drawing/Canvas.vala"
	g_signal_emit (self, gala_drawing_canvas_signals[GALA_DRAWING_CANVAS_DRAW_SIGNAL], 0, _tmp20_, self->priv->width, self->priv->height);
#line 48 "../lib/Drawing/Canvas.vala"
	_cairo_destroy0 (_tmp20_);
#line 50 "../lib/Drawing/Canvas.vala"
	if (mapped_buffer) {
#line 226 "Canvas.c"
		CoglBuffer* _tmp21_;
#line 51 "../lib/Drawing/Canvas.vala"
		_tmp21_ = buffer;
#line 51 "../lib/Drawing/Canvas.vala"
		cogl_buffer_unmap (_tmp21_);
#line 232 "Canvas.c"
	} else {
		gint size = 0;
		cairo_surface_t* _tmp22_;
		CoglBuffer* _tmp23_;
		cairo_surface_t* _tmp24_;
		guchar* _tmp25_;
#line 53 "../lib/Drawing/Canvas.vala"
		_tmp22_ = surface;
#line 53 "../lib/Drawing/Canvas.vala"
		size = cairo_image_surface_get_stride (_tmp22_) * self->priv->height;
#line 54 "../lib/Drawing/Canvas.vala"
		_tmp23_ = buffer;
#line 54 "../lib/Drawing/Canvas.vala"
		_tmp24_ = surface;
#line 54 "../lib/Drawing/Canvas.vala"
		_tmp25_ = cairo_image_surface_get_data (_tmp24_);
#line 54 "../lib/Drawing/Canvas.vala"
		cogl_buffer_set_data (_tmp23_, (gsize) 0, _tmp25_, (gsize) size);
#line 251 "Canvas.c"
	}
#line 19 "../lib/Drawing/Canvas.vala"
	_cairo_destroy0 (cr);
#line 19 "../lib/Drawing/Canvas.vala"
	_cairo_surface_destroy0 (surface);
#line 257 "Canvas.c"
}

static gboolean
gala_drawing_canvas_real_get_preferred_size (ClutterContent* base,
                                             gfloat* out_width,
                                             gfloat* out_height)
{
	GalaDrawingCanvas * self;
	gfloat _vala_out_width = 0.0F;
	gfloat _vala_out_height = 0.0F;
	gboolean _tmp0_ = FALSE;
	gboolean result;
#line 58 "../lib/Drawing/Canvas.vala"
	self = (GalaDrawingCanvas*) base;
#line 59 "../lib/Drawing/Canvas.vala"
	if (self->priv->width < 0) {
#line 59 "../lib/Drawing/Canvas.vala"
		_tmp0_ = TRUE;
#line 276 "Canvas.c"
	} else {
#line 59 "../lib/Drawing/Canvas.vala"
		_tmp0_ = self->priv->width < 0;
#line 280 "Canvas.c"
	}
#line 59 "../lib/Drawing/Canvas.vala"
	if (_tmp0_) {
#line 60 "../lib/Drawing/Canvas.vala"
		_vala_out_width = (gfloat) 0;
#line 61 "../lib/Drawing/Canvas.vala"
		_vala_out_height = (gfloat) 0;
#line 62 "../lib/Drawing/Canvas.vala"
		result = FALSE;
#line 62 "../lib/Drawing/Canvas.vala"
		if (out_width) {
#line 62 "../lib/Drawing/Canvas.vala"
			*out_width = _vala_out_width;
#line 294 "Canvas.c"
		}
#line 62 "../lib/Drawing/Canvas.vala"
		if (out_height) {
#line 62 "../lib/Drawing/Canvas.vala"
			*out_height = _vala_out_height;
#line 300 "Canvas.c"
		}
#line 62 "../lib/Drawing/Canvas.vala"
		return result;
#line 304 "Canvas.c"
	}
#line 65 "../lib/Drawing/Canvas.vala"
	_vala_out_width = ceilf (self->priv->width * self->priv->scale_factor);
#line 66 "../lib/Drawing/Canvas.vala"
	_vala_out_height = ceilf (self->priv->height * self->priv->scale_factor);
#line 68 "../lib/Drawing/Canvas.vala"
	result = TRUE;
#line 68 "../lib/Drawing/Canvas.vala"
	if (out_width) {
#line 68 "../lib/Drawing/Canvas.vala"
		*out_width = _vala_out_width;
#line 316 "Canvas.c"
	}
#line 68 "../lib/Drawing/Canvas.vala"
	if (out_height) {
#line 68 "../lib/Drawing/Canvas.vala"
		*out_height = _vala_out_height;
#line 322 "Canvas.c"
	}
#line 68 "../lib/Drawing/Canvas.vala"
	return result;
#line 326 "Canvas.c"
}

static void
gala_drawing_canvas_real_invalidate (ClutterContent* base)
{
	GalaDrawingCanvas * self;
	gboolean _tmp0_ = FALSE;
#line 71 "../lib/Drawing/Canvas.vala"
	self = (GalaDrawingCanvas*) base;
#line 72 "../lib/Drawing/Canvas.vala"
	_g_object_unref0 (self->priv->bitmap);
#line 72 "../lib/Drawing/Canvas.vala"
	self->priv->bitmap = NULL;
#line 74 "../lib/Drawing/Canvas.vala"
	if (self->priv->width <= 0) {
#line 74 "../lib/Drawing/Canvas.vala"
		_tmp0_ = TRUE;
#line 344 "Canvas.c"
	} else {
#line 74 "../lib/Drawing/Canvas.vala"
		_tmp0_ = self->priv->height <= 0;
#line 348 "Canvas.c"
	}
#line 74 "../lib/Drawing/Canvas.vala"
	if (_tmp0_) {
#line 75 "../lib/Drawing/Canvas.vala"
		return;
#line 354 "Canvas.c"
	}
#line 78 "../lib/Drawing/Canvas.vala"
	gala_drawing_canvas_emit_draw (self);
#line 358 "Canvas.c"
}

static void
gala_drawing_canvas_real_invalidate_size (ClutterContent* base)
{
	GalaDrawingCanvas * self;
#line 81 "../lib/Drawing/Canvas.vala"
	self = (GalaDrawingCanvas*) base;
#line 367 "Canvas.c"
}

static void
gala_drawing_canvas_real_paint_content (ClutterContent* base,
                                        ClutterActor* actor,
                                        ClutterPaintNode* root,
                                        ClutterPaintContext* paint_context)
{
	GalaDrawingCanvas * self;
	CoglBitmap* _tmp0_;
	CoglTexture* _tmp1_;
	CoglTexture* _tmp4_;
	ClutterPaintNode* node = NULL;
	CoglTexture* _tmp5_;
	ClutterPaintNode* _tmp6_;
	ClutterPaintNode* _tmp7_;
#line 83 "../lib/Drawing/Canvas.vala"
	self = (GalaDrawingCanvas*) base;
#line 83 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (actor != NULL);
#line 83 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (root != NULL);
#line 83 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (paint_context != NULL);
#line 84 "../lib/Drawing/Canvas.vala"
	_tmp0_ = self->priv->bitmap;
#line 84 "../lib/Drawing/Canvas.vala"
	if (_tmp0_ == NULL) {
#line 85 "../lib/Drawing/Canvas.vala"
		return;
#line 398 "Canvas.c"
	}
#line 88 "../lib/Drawing/Canvas.vala"
	if (self->priv->dirty) {
#line 89 "../lib/Drawing/Canvas.vala"
		_g_object_unref0 (self->priv->texture);
#line 89 "../lib/Drawing/Canvas.vala"
		self->priv->texture = NULL;
#line 406 "Canvas.c"
	}
#line 92 "../lib/Drawing/Canvas.vala"
	_tmp1_ = self->priv->texture;
#line 92 "../lib/Drawing/Canvas.vala"
	if (_tmp1_ == NULL) {
#line 412 "Canvas.c"
		CoglBitmap* _tmp2_;
		CoglTexture2D* _tmp3_;
#line 93 "../lib/Drawing/Canvas.vala"
		_tmp2_ = self->priv->bitmap;
#line 93 "../lib/Drawing/Canvas.vala"
		_tmp3_ = (CoglTexture2D*) cogl_texture_2d_new_from_bitmap (_tmp2_);
#line 93 "../lib/Drawing/Canvas.vala"
		_g_object_unref0 (self->priv->texture);
#line 93 "../lib/Drawing/Canvas.vala"
		self->priv->texture = (CoglTexture*) _tmp3_;
#line 423 "Canvas.c"
	}
#line 96 "../lib/Drawing/Canvas.vala"
	_tmp4_ = self->priv->texture;
#line 96 "../lib/Drawing/Canvas.vala"
	if (_tmp4_ == NULL) {
#line 97 "../lib/Drawing/Canvas.vala"
		return;
#line 431 "Canvas.c"
	}
#line 100 "../lib/Drawing/Canvas.vala"
	_tmp5_ = self->priv->texture;
#line 100 "../lib/Drawing/Canvas.vala"
	_tmp6_ = clutter_actor_create_texture_paint_node (actor, _tmp5_);
#line 100 "../lib/Drawing/Canvas.vala"
	node = _tmp6_;
#line 101 "../lib/Drawing/Canvas.vala"
	_tmp7_ = node;
#line 101 "../lib/Drawing/Canvas.vala"
	clutter_paint_node_add_child (root, _tmp7_);
#line 103 "../lib/Drawing/Canvas.vala"
	self->priv->dirty = FALSE;
#line 83 "../lib/Drawing/Canvas.vala"
	_clutter_paint_node_unref0 (node);
#line 447 "Canvas.c"
}

void
gala_drawing_canvas_set_size (GalaDrawingCanvas* self,
                              gint new_width,
                              gint new_height)
{
	gboolean _tmp0_ = FALSE;
#line 106 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (self != NULL);
#line 106 "../lib/Drawing/Canvas.vala"
	_vala_return_if_fail ((new_width >= -1) && (new_height >= -1), "new_width >= -1 && new_height >= -1");
#line 107 "../lib/Drawing/Canvas.vala"
	if (new_width == self->priv->width) {
#line 107 "../lib/Drawing/Canvas.vala"
		_tmp0_ = new_height == self->priv->height;
#line 464 "Canvas.c"
	} else {
#line 107 "../lib/Drawing/Canvas.vala"
		_tmp0_ = FALSE;
#line 468 "Canvas.c"
	}
#line 107 "../lib/Drawing/Canvas.vala"
	if (_tmp0_) {
#line 108 "../lib/Drawing/Canvas.vala"
		return;
#line 474 "Canvas.c"
	}
#line 111 "../lib/Drawing/Canvas.vala"
	self->priv->width = new_width;
#line 112 "../lib/Drawing/Canvas.vala"
	self->priv->height = new_height;
#line 114 "../lib/Drawing/Canvas.vala"
	clutter_content_invalidate ((ClutterContent*) self);
#line 482 "Canvas.c"
}

void
gala_drawing_canvas_set_scale_factor (GalaDrawingCanvas* self,
                                      gfloat new_scale_factor)
{
#line 117 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (self != NULL);
#line 117 "../lib/Drawing/Canvas.vala"
	_vala_return_if_fail (new_scale_factor > 0.0f, "new_scale_factor > 0.0f");
#line 118 "../lib/Drawing/Canvas.vala"
	if (new_scale_factor != self->priv->scale_factor) {
#line 119 "../lib/Drawing/Canvas.vala"
		self->priv->scale_factor = new_scale_factor;
#line 121 "../lib/Drawing/Canvas.vala"
		clutter_content_invalidate ((ClutterContent*) self);
#line 499 "Canvas.c"
	}
}

GalaDrawingCanvas*
gala_drawing_canvas_construct (GType object_type)
{
	GalaDrawingCanvas * self = NULL;
#line 7 "../lib/Drawing/Canvas.vala"
	self = (GalaDrawingCanvas*) g_object_new (object_type, NULL);
#line 7 "../lib/Drawing/Canvas.vala"
	return self;
#line 511 "Canvas.c"
}

GalaDrawingCanvas*
gala_drawing_canvas_new (void)
{
#line 7 "../lib/Drawing/Canvas.vala"
	return gala_drawing_canvas_construct (GALA_DRAWING_TYPE_CANVAS);
#line 519 "Canvas.c"
}

static void
g_cclosure_user_marshal_VOID__BOXED_INT_INT (GClosure * closure,
                                             GValue * return_value,
                                             guint n_param_values,
                                             const GValue * param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__BOXED_INT_INT) (gpointer data1, gpointer arg_1, gint arg_2, gint arg_3, gpointer data2);
	register GMarshalFunc_VOID__BOXED_INT_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
#line 7 "../lib/Drawing/Canvas.vala"
	g_return_if_fail (n_param_values == 4);
#line 7 "../lib/Drawing/Canvas.vala"
	if (G_CCLOSURE_SWAP_DATA (closure)) {
#line 7 "../lib/Drawing/Canvas.vala"
		data1 = closure->data;
#line 7 "../lib/Drawing/Canvas.vala"
		data2 = param_values->data[0].v_pointer;
#line 544 "Canvas.c"
	} else {
#line 7 "../lib/Drawing/Canvas.vala"
		data1 = param_values->data[0].v_pointer;
#line 7 "../lib/Drawing/Canvas.vala"
		data2 = closure->data;
#line 550 "Canvas.c"
	}
#line 7 "../lib/Drawing/Canvas.vala"
	callback = (GMarshalFunc_VOID__BOXED_INT_INT) (marshal_data ? marshal_data : cc->callback);
#line 7 "../lib/Drawing/Canvas.vala"
	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_int (param_values + 2), g_value_get_int (param_values + 3), data2);
#line 556 "Canvas.c"
}

static void
gala_drawing_canvas_class_init (GalaDrawingCanvasClass * klass,
                                gpointer klass_data)
{
#line 7 "../lib/Drawing/Canvas.vala"
	gala_drawing_canvas_parent_class = g_type_class_peek_parent (klass);
#line 7 "../lib/Drawing/Canvas.vala"
	g_type_class_adjust_private_offset (klass, &GalaDrawingCanvas_private_offset);
#line 7 "../lib/Drawing/Canvas.vala"
	G_OBJECT_CLASS (klass)->finalize = gala_drawing_canvas_finalize;
#line 7 "../lib/Drawing/Canvas.vala"
	gala_drawing_canvas_signals[GALA_DRAWING_CANVAS_DRAW_SIGNAL] = g_signal_new ("draw", GALA_DRAWING_TYPE_CANVAS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_INT_INT, G_TYPE_NONE, 3, cairo_gobject_context_get_type (), G_TYPE_INT, G_TYPE_INT);
#line 571 "Canvas.c"
}

static void
gala_drawing_canvas_clutter_content_interface_init (ClutterContentInterface * iface,
                                                    gpointer iface_data)
{
#line 7 "../lib/Drawing/Canvas.vala"
	gala_drawing_canvas_clutter_content_parent_iface = g_type_interface_peek_parent (iface);
#line 7 "../lib/Drawing/Canvas.vala"
	iface->get_preferred_size = (gboolean (*) (ClutterContent*, gfloat*, gfloat*)) gala_drawing_canvas_real_get_preferred_size;
#line 7 "../lib/Drawing/Canvas.vala"
	iface->invalidate = (void (*) (ClutterContent*)) gala_drawing_canvas_real_invalidate;
#line 7 "../lib/Drawing/Canvas.vala"
	iface->invalidate_size = (void (*) (ClutterContent*)) gala_drawing_canvas_real_invalidate_size;
#line 7 "../lib/Drawing/Canvas.vala"
	iface->paint_content = (void (*) (ClutterContent*, ClutterActor*, ClutterPaintNode*, ClutterPaintContext*)) gala_drawing_canvas_real_paint_content;
#line 588 "Canvas.c"
}

static void
gala_drawing_canvas_instance_init (GalaDrawingCanvas * self,
                                   gpointer klass)
{
#line 7 "../lib/Drawing/Canvas.vala"
	self->priv = gala_drawing_canvas_get_instance_private (self);
#line 8 "../lib/Drawing/Canvas.vala"
	self->priv->width = -1;
#line 9 "../lib/Drawing/Canvas.vala"
	self->priv->height = -1;
#line 10 "../lib/Drawing/Canvas.vala"
	self->priv->scale_factor = 1.0f;
#line 12 "../lib/Drawing/Canvas.vala"
	self->priv->texture = NULL;
#line 13 "../lib/Drawing/Canvas.vala"
	self->priv->bitmap = NULL;
#line 15 "../lib/Drawing/Canvas.vala"
	self->priv->dirty = FALSE;
#line 609 "Canvas.c"
}

static void
gala_drawing_canvas_finalize (GObject * obj)
{
	GalaDrawingCanvas * self;
#line 7 "../lib/Drawing/Canvas.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GALA_DRAWING_TYPE_CANVAS, GalaDrawingCanvas);
#line 12 "../lib/Drawing/Canvas.vala"
	_g_object_unref0 (self->priv->texture);
#line 13 "../lib/Drawing/Canvas.vala"
	_g_object_unref0 (self->priv->bitmap);
#line 7 "../lib/Drawing/Canvas.vala"
	G_OBJECT_CLASS (gala_drawing_canvas_parent_class)->finalize (obj);
#line 624 "Canvas.c"
}

 G_GNUC_NO_INLINE static GType
gala_drawing_canvas_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GalaDrawingCanvasClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gala_drawing_canvas_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GalaDrawingCanvas), 0, (GInstanceInitFunc) gala_drawing_canvas_instance_init, NULL };
	static const GInterfaceInfo clutter_content_info = { (GInterfaceInitFunc) gala_drawing_canvas_clutter_content_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType gala_drawing_canvas_type_id;
	gala_drawing_canvas_type_id = g_type_register_static (G_TYPE_OBJECT, "GalaDrawingCanvas", &g_define_type_info, 0);
	g_type_add_interface_static (gala_drawing_canvas_type_id, clutter_content_get_type (), &clutter_content_info);
	GalaDrawingCanvas_private_offset = g_type_add_instance_private (gala_drawing_canvas_type_id, sizeof (GalaDrawingCanvasPrivate));
	return gala_drawing_canvas_type_id;
}

GType
gala_drawing_canvas_get_type (void)
{
	static gsize gala_drawing_canvas_type_id__once = 0;
	if (g_once_init_enter (&gala_drawing_canvas_type_id__once)) {
		GType gala_drawing_canvas_type_id;
		gala_drawing_canvas_type_id = gala_drawing_canvas_get_type_once ();
		g_once_init_leave (&gala_drawing_canvas_type_id__once, gala_drawing_canvas_type_id);
	}
	return gala_drawing_canvas_type_id__once;
}

