/* Plugin.c generated by valac 0.56.17, the Vala compiler
 * generated from Plugin.vala, do not modify */

/**/
/*  Copyright (C) 2014 Tom Beckmann*/
/**/
/*  This program is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  This program is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include "gala.h"
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <mtk/mtk.h>
#include <clutter/clutter.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))
enum  {
	GALA_PLUGIN_0_PROPERTY,
	GALA_PLUGIN_FREEZE_TRACK_PROPERTY,
	GALA_PLUGIN_NUM_PROPERTIES
};
static GParamSpec* gala_plugin_properties[GALA_PLUGIN_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	GALA_PLUGIN_REGION_CHANGED_SIGNAL,
	GALA_PLUGIN_NUM_SIGNALS
};
static guint gala_plugin_signals[GALA_PLUGIN_NUM_SIGNALS] = {0};

struct _GalaPluginPrivate {
	MtkRectangle* region;
	gint region_length1;
	gint _region_size_;
	MtkRectangle* _custom_region;
	gint _custom_region_length1;
	gint __custom_region_size_;
	gboolean _freeze_track;
	GList* tracked_actors;
};

static gint GalaPlugin_private_offset;
static gpointer gala_plugin_parent_class = NULL;

static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static MtkRectangle* _vala_array_dup1 (MtkRectangle* self,
                                gssize length);
static void gala_plugin_real_initialize (GalaPlugin* self,
                                  GalaWindowManager* wm);
static void gala_plugin_real_destroy (GalaPlugin* self);
static void gala_plugin_on_actor_allocation_changed (GalaPlugin* self,
                                              GObject* actor_object,
                                              GParamSpec* pspec);
static void _gala_plugin_on_actor_allocation_changed_g_object_notify (GObject* _sender,
                                                               GParamSpec* pspec,
                                                               gpointer self);
static MtkRectangle* _vala_array_dup2 (MtkRectangle* self,
                                gssize length);
static void gala_plugin_finalize (GObject * obj);
static GType gala_plugin_get_type_once (void);
static void _vala_gala_plugin_get_property (GObject * object,
                                     guint property_id,
                                     GValue * value,
                                     GParamSpec * pspec);
static void _vala_gala_plugin_set_property (GObject * object,
                                     guint property_id,
                                     const GValue * value,
                                     GParamSpec * pspec);

 G_GNUC_NO_INLINE static GType
gala_plugin_function_get_type_once (void)
{
	static const GEnumValue values[] = {{GALA_PLUGIN_FUNCTION_ADDITION, "GALA_PLUGIN_FUNCTION_ADDITION", "addition"}, {GALA_PLUGIN_FUNCTION_WINDOW_SWITCHER, "GALA_PLUGIN_FUNCTION_WINDOW_SWITCHER", "window-switcher"}, {GALA_PLUGIN_FUNCTION_WORKSPACE_VIEW, "GALA_PLUGIN_FUNCTION_WORKSPACE_VIEW", "workspace-view"}, {GALA_PLUGIN_FUNCTION_WINDOW_OVERVIEW, "GALA_PLUGIN_FUNCTION_WINDOW_OVERVIEW", "window-overview"}, {0, NULL, NULL}};
	GType gala_plugin_function_type_id;
	gala_plugin_function_type_id = g_enum_register_static ("GalaPluginFunction", values);
	return gala_plugin_function_type_id;
}

GType
gala_plugin_function_get_type (void)
{
	static gsize gala_plugin_function_type_id__once = 0;
	if (g_once_init_enter (&gala_plugin_function_type_id__once)) {
		GType gala_plugin_function_type_id;
		gala_plugin_function_type_id = gala_plugin_function_get_type_once ();
		g_once_init_leave (&gala_plugin_function_type_id__once, gala_plugin_function_type_id);
	}
	return gala_plugin_function_type_id__once;
}

 G_GNUC_NO_INLINE static GType
gala_load_priority_get_type_once (void)
{
	static const GEnumValue values[] = {{GALA_LOAD_PRIORITY_IMMEDIATE, "GALA_LOAD_PRIORITY_IMMEDIATE", "immediate"}, {GALA_LOAD_PRIORITY_DEFERRED, "GALA_LOAD_PRIORITY_DEFERRED", "deferred"}, {0, NULL, NULL}};
	GType gala_load_priority_type_id;
	gala_load_priority_type_id = g_enum_register_static ("GalaLoadPriority", values);
	return gala_load_priority_type_id;
}

GType
gala_load_priority_get_type (void)
{
	static gsize gala_load_priority_type_id__once = 0;
	if (g_once_init_enter (&gala_load_priority_type_id__once)) {
		GType gala_load_priority_type_id;
		gala_load_priority_type_id = gala_load_priority_get_type_once ();
		g_once_init_leave (&gala_load_priority_type_id__once, gala_load_priority_type_id);
	}
	return gala_load_priority_type_id__once;
}

void
gala_plugin_info_copy (const GalaPluginInfo* self,
                       GalaPluginInfo* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
#line 38 "../lib/Plugin.vala"
	_tmp0_ = (*self).name;
#line 38 "../lib/Plugin.vala"
	_tmp1_ = g_strdup (_tmp0_);
#line 38 "../lib/Plugin.vala"
	_g_free0 ((*dest).name);
#line 38 "../lib/Plugin.vala"
	(*dest).name = _tmp1_;
#line 38 "../lib/Plugin.vala"
	_tmp2_ = (*self).author;
#line 38 "../lib/Plugin.vala"
	_tmp3_ = g_strdup (_tmp2_);
#line 38 "../lib/Plugin.vala"
	_g_free0 ((*dest).author);
#line 38 "../lib/Plugin.vala"
	(*dest).author = _tmp3_;
#line 38 "../lib/Plugin.vala"
	(*dest).plugin_type = (*self).plugin_type;
#line 38 "../lib/Plugin.vala"
	(*dest).provides = (*self).provides;
#line 38 "../lib/Plugin.vala"
	(*dest).load_priority = (*self).load_priority;
#line 38 "../lib/Plugin.vala"
	_tmp4_ = (*self).module_name;
#line 38 "../lib/Plugin.vala"
	_tmp5_ = g_strdup (_tmp4_);
#line 38 "../lib/Plugin.vala"
	_g_free0 ((*dest).module_name);
#line 38 "../lib/Plugin.vala"
	(*dest).module_name = _tmp5_;
#line 177 "Plugin.c"
}

void
gala_plugin_info_destroy (GalaPluginInfo* self)
{
#line 39 "../lib/Plugin.vala"
	_g_free0 ((*self).name);
#line 40 "../lib/Plugin.vala"
	_g_free0 ((*self).author);
#line 65 "../lib/Plugin.vala"
	_g_free0 ((*self).module_name);
#line 189 "Plugin.c"
}

GalaPluginInfo*
gala_plugin_info_dup (const GalaPluginInfo* self)
{
	GalaPluginInfo* dup;
#line 38 "../lib/Plugin.vala"
	dup = g_new0 (GalaPluginInfo, 1);
#line 38 "../lib/Plugin.vala"
	gala_plugin_info_copy (self, dup);
#line 38 "../lib/Plugin.vala"
	return dup;
#line 202 "Plugin.c"
}

void
gala_plugin_info_free (GalaPluginInfo* self)
{
#line 38 "../lib/Plugin.vala"
	gala_plugin_info_destroy (self);
#line 38 "../lib/Plugin.vala"
	g_free (self);
#line 212 "Plugin.c"
}

 G_GNUC_NO_INLINE static GType
gala_plugin_info_get_type_once (void)
{
	GType gala_plugin_info_type_id;
	gala_plugin_info_type_id = g_boxed_type_register_static ("GalaPluginInfo", (GBoxedCopyFunc) gala_plugin_info_dup, (GBoxedFreeFunc) gala_plugin_info_free);
	return gala_plugin_info_type_id;
}

GType
gala_plugin_info_get_type (void)
{
	static gsize gala_plugin_info_type_id__once = 0;
	if (g_once_init_enter (&gala_plugin_info_type_id__once)) {
		GType gala_plugin_info_type_id;
		gala_plugin_info_type_id = gala_plugin_info_get_type_once ();
		g_once_init_leave (&gala_plugin_info_type_id__once, gala_plugin_info_type_id);
	}
	return gala_plugin_info_type_id__once;
}

static inline gpointer
gala_plugin_get_instance_private (GalaPlugin* self)
{
	return G_STRUCT_MEMBER_P (self, GalaPlugin_private_offset);
}

static void
_g_object_unref0_ (gpointer var)
{
#line 137 "../lib/Plugin.vala"
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
#line 246 "Plugin.c"
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
#line 137 "../lib/Plugin.vala"
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
#line 254 "Plugin.c"
}

MtkRectangle*
gala_plugin_get_region (GalaPlugin* self,
                        gint* result_length1)
{
	MtkRectangle* _tmp0_;
	gint _tmp0__length1;
	MtkRectangle* _tmp1_;
	gint _tmp1__length1;
	MtkRectangle* result;
#line 90 "../lib/Plugin.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 95 "../lib/Plugin.vala"
	_tmp0_ = self->priv->region;
#line 95 "../lib/Plugin.vala"
	_tmp0__length1 = self->priv->region_length1;
#line 95 "../lib/Plugin.vala"
	_tmp1_ = _tmp0_;
#line 95 "../lib/Plugin.vala"
	_tmp1__length1 = _tmp0__length1;
#line 95 "../lib/Plugin.vala"
	if (result_length1) {
#line 95 "../lib/Plugin.vala"
		*result_length1 = _tmp1__length1;
#line 280 "Plugin.c"
	}
#line 95 "../lib/Plugin.vala"
	result = _tmp1_;
#line 95 "../lib/Plugin.vala"
	return result;
#line 286 "Plugin.c"
}

MtkRectangle*
gala_plugin_get_custom_region (GalaPlugin* self,
                               gint* result_length1)
{
	MtkRectangle* _tmp0_;
	gint _tmp0__length1;
	MtkRectangle* _tmp1_;
	gint _tmp1__length1;
	MtkRectangle* result;
#line 104 "../lib/Plugin.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 109 "../lib/Plugin.vala"
	_tmp0_ = self->priv->_custom_region;
#line 109 "../lib/Plugin.vala"
	_tmp0__length1 = self->priv->_custom_region_length1;
#line 109 "../lib/Plugin.vala"
	_tmp1_ = _tmp0_;
#line 109 "../lib/Plugin.vala"
	_tmp1__length1 = _tmp0__length1;
#line 109 "../lib/Plugin.vala"
	if (result_length1) {
#line 109 "../lib/Plugin.vala"
		*result_length1 = _tmp1__length1;
#line 312 "Plugin.c"
	}
#line 109 "../lib/Plugin.vala"
	result = _tmp1_;
#line 109 "../lib/Plugin.vala"
	return result;
#line 318 "Plugin.c"
}

static MtkRectangle*
_vala_array_dup1 (MtkRectangle* self,
                  gssize length)
{
#line 116 "../lib/Plugin.vala"
	if (length > 0) {
#line 116 "../lib/Plugin.vala"
		return g_memdup2 (self, length * sizeof (MtkRectangle));
#line 329 "Plugin.c"
	}
#line 116 "../lib/Plugin.vala"
	return NULL;
#line 333 "Plugin.c"
}

void
gala_plugin_set_custom_region (GalaPlugin* self,
                               MtkRectangle* custom_region,
                               gint custom_region_length1)
{
	MtkRectangle* _tmp0_;
	gint _tmp0__length1;
#line 112 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 116 "../lib/Plugin.vala"
	_tmp0_ = (custom_region != NULL) ? _vala_array_dup1 (custom_region, custom_region_length1) : custom_region;
#line 116 "../lib/Plugin.vala"
	_tmp0__length1 = custom_region_length1;
#line 116 "../lib/Plugin.vala"
	self->priv->_custom_region = (g_free (self->priv->_custom_region), NULL);
#line 116 "../lib/Plugin.vala"
	self->priv->_custom_region = _tmp0_;
#line 116 "../lib/Plugin.vala"
	self->priv->_custom_region_length1 = _tmp0__length1;
#line 116 "../lib/Plugin.vala"
	self->priv->__custom_region_size_ = self->priv->_custom_region_length1;
#line 117 "../lib/Plugin.vala"
	gala_plugin_update_region (self);
#line 359 "Plugin.c"
}

/**
         * Once this method is called you can start adding actors to the stage
         * via the windowmanager instance that is given to you.
         *
         * @param wm The window manager.
         */
static void
gala_plugin_real_initialize (GalaPlugin* self,
                             GalaWindowManager* wm)
{
#line 145 "../lib/Plugin.vala"
	g_critical ("Type `%s' does not implement abstract method `gala_plugin_initialize'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
#line 145 "../lib/Plugin.vala"
	return;
#line 376 "Plugin.c"
}

void
gala_plugin_initialize (GalaPlugin* self,
                        GalaWindowManager* wm)
{
	GalaPluginClass* _klass_;
#line 145 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 145 "../lib/Plugin.vala"
	_klass_ = GALA_PLUGIN_GET_CLASS (self);
#line 145 "../lib/Plugin.vala"
	if (_klass_->initialize) {
#line 145 "../lib/Plugin.vala"
		_klass_->initialize (self, wm);
#line 392 "Plugin.c"
	}
}

/**
         * This method is currently not called in the code, however you should
         * still implement it to be compatible whenever we decide to use it.
         * It should make sure that everything your plugin added to the stage
         * is cleaned up.
         */
static void
gala_plugin_real_destroy (GalaPlugin* self)
{
#line 153 "../lib/Plugin.vala"
	g_critical ("Type `%s' does not implement abstract method `gala_plugin_destroy'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
#line 153 "../lib/Plugin.vala"
	return;
#line 409 "Plugin.c"
}

void
gala_plugin_destroy (GalaPlugin* self)
{
	GalaPluginClass* _klass_;
#line 153 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 153 "../lib/Plugin.vala"
	_klass_ = GALA_PLUGIN_GET_CLASS (self);
#line 153 "../lib/Plugin.vala"
	if (_klass_->destroy) {
#line 153 "../lib/Plugin.vala"
		_klass_->destroy (self);
#line 424 "Plugin.c"
	}
}

/**
         * Listen to changes to the allocation of actor and update the region
         * accordingly. You may add multiple actors, their shapes will be
         * combined when one of them changes.
         *
         * @param actor The actor to be tracked
         */
static gpointer
_g_object_ref0 (gpointer self)
{
#line 163 "../lib/Plugin.vala"
	return self ? g_object_ref (self) : NULL;
#line 440 "Plugin.c"
}

static void
_gala_plugin_on_actor_allocation_changed_g_object_notify (GObject* _sender,
                                                          GParamSpec* pspec,
                                                          gpointer self)
{
#line 164 "../lib/Plugin.vala"
	gala_plugin_on_actor_allocation_changed ((GalaPlugin*) self, _sender, pspec);
#line 450 "Plugin.c"
}

void
gala_plugin_track_actor (GalaPlugin* self,
                         ClutterActor* actor)
{
	ClutterActor* _tmp0_;
#line 162 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 162 "../lib/Plugin.vala"
	g_return_if_fail (actor != NULL);
#line 163 "../lib/Plugin.vala"
	_tmp0_ = _g_object_ref0 (actor);
#line 163 "../lib/Plugin.vala"
	self->priv->tracked_actors = g_list_prepend (self->priv->tracked_actors, _tmp0_);
#line 164 "../lib/Plugin.vala"
	g_signal_connect_object ((GObject*) actor, "notify::allocation", (GCallback) _gala_plugin_on_actor_allocation_changed_g_object_notify, self, 0);
#line 166 "../lib/Plugin.vala"
	gala_plugin_update_region (self);
#line 470 "Plugin.c"
}

/**
         * Stop listening to allocation changes and remove the actor's
         * allocation from the region array.
         *
         * @param actor The actor to stop listening the changes on
         */
static GList*
vala_g_list_remove_full (GList* self,
                         gconstpointer data,
                         GFreeFunc func)
{
	GList* l = NULL;
	GList* result;
#line 5230 "glib-2.0.vapi"
	l = self;
#line 5231 "glib-2.0.vapi"
	while (TRUE) {
#line 490 "Plugin.c"
		GList* _tmp0_;
		GList* _tmp1_;
		gconstpointer _tmp2_;
#line 5231 "glib-2.0.vapi"
		_tmp0_ = l;
#line 5231 "glib-2.0.vapi"
		if (!(_tmp0_ != NULL)) {
#line 5231 "glib-2.0.vapi"
			break;
#line 500 "Plugin.c"
		}
#line 5232 "glib-2.0.vapi"
		_tmp1_ = l;
#line 5232 "glib-2.0.vapi"
		_tmp2_ = ((GList*) _tmp1_)->data;
#line 5232 "glib-2.0.vapi"
		if (_tmp2_ != data) {
#line 508 "Plugin.c"
			GList* _tmp3_;
			GList* _tmp4_;
#line 5233 "glib-2.0.vapi"
			_tmp3_ = l;
#line 5233 "glib-2.0.vapi"
			_tmp4_ = ((GList*) _tmp3_)->next;
#line 5233 "glib-2.0.vapi"
			l = _tmp4_;
#line 517 "Plugin.c"
		} else {
			GList* _tmp5_;
			gconstpointer _tmp6_;
			GList* _tmp7_;
#line 5235 "glib-2.0.vapi"
			_tmp5_ = l;
#line 5235 "glib-2.0.vapi"
			_tmp6_ = ((GList*) _tmp5_)->data;
#line 5235 "glib-2.0.vapi"
			func (_tmp6_);
#line 5236 "glib-2.0.vapi"
			_tmp7_ = l;
#line 5236 "glib-2.0.vapi"
			self = g_list_delete_link (self, (GList*) _tmp7_);
#line 5237 "glib-2.0.vapi"
			break;
#line 534 "Plugin.c"
		}
	}
#line 5240 "glib-2.0.vapi"
	result = self;
#line 5240 "glib-2.0.vapi"
	return result;
#line 541 "Plugin.c"
}

void
gala_plugin_untrack_actor (GalaPlugin* self,
                           ClutterActor* actor)
{
	guint _tmp0_;
	GQuark _tmp1_;
#line 175 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 175 "../lib/Plugin.vala"
	g_return_if_fail (actor != NULL);
#line 176 "../lib/Plugin.vala"
	self->priv->tracked_actors = vala_g_list_remove_full (self->priv->tracked_actors, actor, _g_object_unref0_);
#line 177 "../lib/Plugin.vala"
	g_signal_parse_name ("notify::allocation", G_TYPE_OBJECT, &_tmp0_, &_tmp1_, TRUE);
#line 177 "../lib/Plugin.vala"
	g_signal_handlers_disconnect_matched ((GObject*) actor, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, _tmp1_, NULL, (GCallback) _gala_plugin_on_actor_allocation_changed_g_object_notify, self);
#line 560 "Plugin.c"
}

/**
         * You can call this method to force the system to update the region that
         * is used by the window manager. It will automatically upon changes to
         * the custom_region property and when a tracked actor's allocation changes
         * unless freeze_track is set to true. You may need to call this function
         * after setting freeze_track back to false after an animation to make the
         * wm aware of the new position of the actor in question.
         */
static MtkRectangle*
_vala_array_dup2 (MtkRectangle* self,
                  gssize length)
{
#line 217 "../lib/Plugin.vala"
	if (length > 0) {
#line 217 "../lib/Plugin.vala"
		return g_memdup2 (self, length * sizeof (MtkRectangle));
#line 579 "Plugin.c"
	}
#line 217 "../lib/Plugin.vala"
	return NULL;
#line 583 "Plugin.c"
}

void
gala_plugin_update_region (GalaPlugin* self)
{
	MtkRectangle* custom_region = NULL;
	gint _tmp0_ = 0;
	MtkRectangle* _tmp1_;
	gint custom_region_length1;
	gint _custom_region_size_;
	gboolean has_custom = FALSE;
	MtkRectangle* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_ = 0;
	guint len = 0U;
	GList* _tmp5_;
	MtkRectangle* regions = NULL;
	MtkRectangle* _tmp6_;
	gint regions_length1;
	gint _regions_size_;
	gint i = 0;
	GList* _tmp14_;
	MtkRectangle* _tmp30_;
	gint _tmp30__length1;
	MtkRectangle* _tmp31_;
	gint _tmp31__length1;
#line 188 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 189 "../lib/Plugin.vala"
	_tmp1_ = gala_plugin_get_custom_region (self, &_tmp0_);
#line 189 "../lib/Plugin.vala"
	custom_region = _tmp1_;
#line 189 "../lib/Plugin.vala"
	custom_region_length1 = _tmp0_;
#line 189 "../lib/Plugin.vala"
	_custom_region_size_ = custom_region_length1;
#line 190 "../lib/Plugin.vala"
	_tmp2_ = custom_region;
#line 190 "../lib/Plugin.vala"
	_tmp2__length1 = custom_region_length1;
#line 190 "../lib/Plugin.vala"
	has_custom = _tmp2_ != NULL;
#line 191 "../lib/Plugin.vala"
	if (has_custom) {
#line 628 "Plugin.c"
		MtkRectangle* _tmp4_;
		gint _tmp4__length1;
#line 191 "../lib/Plugin.vala"
		_tmp4_ = custom_region;
#line 191 "../lib/Plugin.vala"
		_tmp4__length1 = custom_region_length1;
#line 191 "../lib/Plugin.vala"
		_tmp3_ = _tmp4__length1;
#line 637 "Plugin.c"
	} else {
#line 191 "../lib/Plugin.vala"
		_tmp3_ = 0;
#line 641 "Plugin.c"
	}
#line 191 "../lib/Plugin.vala"
	_tmp5_ = self->priv->tracked_actors;
#line 191 "../lib/Plugin.vala"
	len = g_list_length (_tmp5_) + _tmp3_;
#line 194 "../lib/Plugin.vala"
	_tmp6_ = g_new0 (MtkRectangle, len);
#line 194 "../lib/Plugin.vala"
	regions = _tmp6_;
#line 194 "../lib/Plugin.vala"
	regions_length1 = len;
#line 194 "../lib/Plugin.vala"
	_regions_size_ = regions_length1;
#line 198 "../lib/Plugin.vala"
	i = 0;
#line 200 "../lib/Plugin.vala"
	if (has_custom) {
#line 659 "Plugin.c"
		{
			gint j = 0;
#line 201 "../lib/Plugin.vala"
			j = 0;
#line 664 "Plugin.c"
			{
				gboolean _tmp7_ = FALSE;
#line 201 "../lib/Plugin.vala"
				_tmp7_ = TRUE;
#line 201 "../lib/Plugin.vala"
				while (TRUE) {
#line 671 "Plugin.c"
					MtkRectangle* _tmp9_;
					gint _tmp9__length1;
					MtkRectangle* _tmp10_;
					gint _tmp10__length1;
					gint _tmp11_;
					MtkRectangle* _tmp12_;
					gint _tmp12__length1;
					MtkRectangle _tmp13_;
#line 201 "../lib/Plugin.vala"
					if (!_tmp7_) {
#line 682 "Plugin.c"
						gint _tmp8_;
#line 201 "../lib/Plugin.vala"
						_tmp8_ = j;
#line 201 "../lib/Plugin.vala"
						j = _tmp8_ + 1;
#line 688 "Plugin.c"
					}
#line 201 "../lib/Plugin.vala"
					_tmp7_ = FALSE;
#line 201 "../lib/Plugin.vala"
					_tmp9_ = custom_region;
#line 201 "../lib/Plugin.vala"
					_tmp9__length1 = custom_region_length1;
#line 201 "../lib/Plugin.vala"
					if (!(j < _tmp9__length1)) {
#line 201 "../lib/Plugin.vala"
						break;
#line 700 "Plugin.c"
					}
#line 202 "../lib/Plugin.vala"
					_tmp10_ = regions;
#line 202 "../lib/Plugin.vala"
					_tmp10__length1 = regions_length1;
#line 202 "../lib/Plugin.vala"
					_tmp11_ = i;
#line 202 "../lib/Plugin.vala"
					i = _tmp11_ + 1;
#line 202 "../lib/Plugin.vala"
					_tmp12_ = custom_region;
#line 202 "../lib/Plugin.vala"
					_tmp12__length1 = custom_region_length1;
#line 202 "../lib/Plugin.vala"
					_tmp13_ = _tmp12_[j];
#line 202 "../lib/Plugin.vala"
					_tmp10_[_tmp11_] = _tmp13_;
#line 718 "Plugin.c"
				}
			}
		}
	}
#line 206 "../lib/Plugin.vala"
	_tmp14_ = self->priv->tracked_actors;
#line 725 "Plugin.c"
	{
		GList* actor_collection = NULL;
		GList* actor_it = NULL;
#line 206 "../lib/Plugin.vala"
		actor_collection = _tmp14_;
#line 206 "../lib/Plugin.vala"
		for (actor_it = actor_collection; actor_it != NULL; actor_it = actor_it->next) {
#line 733 "Plugin.c"
			ClutterActor* _tmp15_;
			ClutterActor* actor = NULL;
#line 206 "../lib/Plugin.vala"
			_tmp15_ = _g_object_ref0 ((ClutterActor*) actor_it->data);
#line 206 "../lib/Plugin.vala"
			actor = _tmp15_;
#line 740 "Plugin.c"
			{
				gfloat x = 0.0F;
				gfloat y = 0.0F;
				gfloat w = 0.0F;
				gfloat h = 0.0F;
				ClutterActor* _tmp16_;
				gfloat _tmp17_ = 0.0F;
				gfloat _tmp18_ = 0.0F;
				ClutterActor* _tmp19_;
				gfloat _tmp20_ = 0.0F;
				gfloat _tmp21_ = 0.0F;
				gboolean _tmp22_ = FALSE;
				MtkRectangle* _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				gfloat _tmp25_;
				gfloat _tmp26_;
				gfloat _tmp27_;
				gfloat _tmp28_;
				MtkRectangle _tmp29_ = {0};
#line 208 "../lib/Plugin.vala"
				_tmp16_ = actor;
#line 208 "../lib/Plugin.vala"
				clutter_actor_get_transformed_position (_tmp16_, &_tmp17_, &_tmp18_);
#line 208 "../lib/Plugin.vala"
				x = _tmp17_;
#line 208 "../lib/Plugin.vala"
				y = _tmp18_;
#line 209 "../lib/Plugin.vala"
				_tmp19_ = actor;
#line 209 "../lib/Plugin.vala"
				clutter_actor_get_transformed_size (_tmp19_, &_tmp20_, &_tmp21_);
#line 209 "../lib/Plugin.vala"
				w = _tmp20_;
#line 209 "../lib/Plugin.vala"
				h = _tmp21_;
#line 211 "../lib/Plugin.vala"
				if (w == ((gfloat) 0)) {
#line 211 "../lib/Plugin.vala"
					_tmp22_ = TRUE;
#line 781 "Plugin.c"
				} else {
#line 211 "../lib/Plugin.vala"
					_tmp22_ = h == ((gfloat) 0);
#line 785 "Plugin.c"
				}
#line 211 "../lib/Plugin.vala"
				if (_tmp22_) {
#line 212 "../lib/Plugin.vala"
					_g_object_unref0 (actor);
#line 212 "../lib/Plugin.vala"
					continue;
#line 793 "Plugin.c"
				}
#line 214 "../lib/Plugin.vala"
				_tmp23_ = regions;
#line 214 "../lib/Plugin.vala"
				_tmp23__length1 = regions_length1;
#line 214 "../lib/Plugin.vala"
				_tmp24_ = i;
#line 214 "../lib/Plugin.vala"
				i = _tmp24_ + 1;
#line 214 "../lib/Plugin.vala"
				_tmp25_ = x;
#line 214 "../lib/Plugin.vala"
				_tmp26_ = y;
#line 214 "../lib/Plugin.vala"
				_tmp27_ = w;
#line 214 "../lib/Plugin.vala"
				_tmp28_ = h;
#line 214 "../lib/Plugin.vala"
				_tmp29_.x = (gint) _tmp25_;
#line 214 "../lib/Plugin.vala"
				_tmp29_.y = (gint) _tmp26_;
#line 214 "../lib/Plugin.vala"
				_tmp29_.width = (gint) _tmp27_;
#line 214 "../lib/Plugin.vala"
				_tmp29_.height = (gint) _tmp28_;
#line 214 "../lib/Plugin.vala"
				_tmp23_[_tmp24_] = _tmp29_;
#line 206 "../lib/Plugin.vala"
				_g_object_unref0 (actor);
#line 823 "Plugin.c"
			}
		}
	}
#line 217 "../lib/Plugin.vala"
	_tmp30_ = regions;
#line 217 "../lib/Plugin.vala"
	_tmp30__length1 = regions_length1;
#line 217 "../lib/Plugin.vala"
	_tmp31_ = (_tmp30_ != NULL) ? _vala_array_dup2 (_tmp30_, _tmp30__length1) : _tmp30_;
#line 217 "../lib/Plugin.vala"
	_tmp31__length1 = _tmp30__length1;
#line 217 "../lib/Plugin.vala"
	self->priv->region = (g_free (self->priv->region), NULL);
#line 217 "../lib/Plugin.vala"
	self->priv->region = _tmp31_;
#line 217 "../lib/Plugin.vala"
	self->priv->region_length1 = _tmp31__length1;
#line 217 "../lib/Plugin.vala"
	self->priv->_region_size_ = self->priv->region_length1;
#line 219 "../lib/Plugin.vala"
	g_signal_emit (self, gala_plugin_signals[GALA_PLUGIN_REGION_CHANGED_SIGNAL], 0);
#line 188 "../lib/Plugin.vala"
	regions = (g_free (regions), NULL);
#line 847 "Plugin.c"
}

static void
gala_plugin_on_actor_allocation_changed (GalaPlugin* self,
                                         GObject* actor_object,
                                         GParamSpec* pspec)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
#line 222 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 222 "../lib/Plugin.vala"
	g_return_if_fail (actor_object != NULL);
#line 222 "../lib/Plugin.vala"
	g_return_if_fail (pspec != NULL);
#line 223 "../lib/Plugin.vala"
	_tmp0_ = gala_plugin_get_freeze_track (self);
#line 223 "../lib/Plugin.vala"
	_tmp1_ = _tmp0_;
#line 223 "../lib/Plugin.vala"
	if (!_tmp1_) {
#line 224 "../lib/Plugin.vala"
		gala_plugin_update_region (self);
#line 871 "Plugin.c"
	}
}

GalaPlugin*
gala_plugin_construct (GType object_type)
{
	GalaPlugin * self = NULL;
#line 75 "../lib/Plugin.vala"
	self = (GalaPlugin*) g_object_new (object_type, NULL);
#line 75 "../lib/Plugin.vala"
	return self;
#line 883 "Plugin.c"
}

gboolean
gala_plugin_get_freeze_track (GalaPlugin* self)
{
	gboolean result;
#line 125 "../lib/Plugin.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 126 "../lib/Plugin.vala"
	result = self->priv->_freeze_track;
#line 126 "../lib/Plugin.vala"
	return result;
#line 896 "Plugin.c"
}

void
gala_plugin_set_freeze_track (GalaPlugin* self,
                              gboolean value)
{
#line 128 "../lib/Plugin.vala"
	g_return_if_fail (self != NULL);
#line 129 "../lib/Plugin.vala"
	self->priv->_freeze_track = value;
#line 131 "../lib/Plugin.vala"
	if (!self->priv->_freeze_track) {
#line 132 "../lib/Plugin.vala"
		gala_plugin_update_region (self);
#line 911 "Plugin.c"
	}
#line 128 "../lib/Plugin.vala"
	g_object_notify_by_pspec ((GObject *) self, gala_plugin_properties[GALA_PLUGIN_FREEZE_TRACK_PROPERTY]);
#line 915 "Plugin.c"
}

static void
gala_plugin_class_init (GalaPluginClass * klass,
                        gpointer klass_data)
{
#line 75 "../lib/Plugin.vala"
	gala_plugin_parent_class = g_type_class_peek_parent (klass);
#line 75 "../lib/Plugin.vala"
	g_type_class_adjust_private_offset (klass, &GalaPlugin_private_offset);
#line 75 "../lib/Plugin.vala"
	((GalaPluginClass *) klass)->initialize = (void (*) (GalaPlugin*, GalaWindowManager*)) gala_plugin_real_initialize;
#line 75 "../lib/Plugin.vala"
	((GalaPluginClass *) klass)->destroy = (void (*) (GalaPlugin*)) gala_plugin_real_destroy;
#line 75 "../lib/Plugin.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_gala_plugin_get_property;
#line 75 "../lib/Plugin.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_gala_plugin_set_property;
#line 75 "../lib/Plugin.vala"
	G_OBJECT_CLASS (klass)->finalize = gala_plugin_finalize;
#line 936 "Plugin.c"
	/**
	         * Set this property to true while animating an actor if you have tracked
	         * actors to prevent constant recalculations of the regions during an
	         * animation.
	         */
#line 75 "../lib/Plugin.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), GALA_PLUGIN_FREEZE_TRACK_PROPERTY, gala_plugin_properties[GALA_PLUGIN_FREEZE_TRACK_PROPERTY] = g_param_spec_boolean ("freeze-track", "freeze-track", "freeze-track", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 944 "Plugin.c"
	/**
	         * Emitted when update_region is called. Mainly for internal purposes.
	         */
#line 75 "../lib/Plugin.vala"
	gala_plugin_signals[GALA_PLUGIN_REGION_CHANGED_SIGNAL] = g_signal_new ("region-changed", GALA_TYPE_PLUGIN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
#line 950 "Plugin.c"
}

static void
gala_plugin_instance_init (GalaPlugin * self,
                           gpointer klass)
{
#line 75 "../lib/Plugin.vala"
	self->priv = gala_plugin_get_instance_private (self);
#line 103 "../lib/Plugin.vala"
	self->priv->_custom_region = NULL;
#line 103 "../lib/Plugin.vala"
	self->priv->_custom_region_length1 = 0;
#line 103 "../lib/Plugin.vala"
	self->priv->__custom_region_size_ = self->priv->_custom_region_length1;
#line 136 "../lib/Plugin.vala"
	self->priv->_freeze_track = FALSE;
#line 137 "../lib/Plugin.vala"
	self->priv->tracked_actors = NULL;
#line 969 "Plugin.c"
}

static void
gala_plugin_finalize (GObject * obj)
{
	GalaPlugin * self;
#line 75 "../lib/Plugin.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GALA_TYPE_PLUGIN, GalaPlugin);
#line 89 "../lib/Plugin.vala"
	self->priv->region = (g_free (self->priv->region), NULL);
#line 103 "../lib/Plugin.vala"
	self->priv->_custom_region = (g_free (self->priv->_custom_region), NULL);
#line 137 "../lib/Plugin.vala"
	(self->priv->tracked_actors == NULL) ? NULL : (self->priv->tracked_actors = (_g_list_free__g_object_unref0_ (self->priv->tracked_actors), NULL));
#line 75 "../lib/Plugin.vala"
	G_OBJECT_CLASS (gala_plugin_parent_class)->finalize (obj);
#line 986 "Plugin.c"
}

/**
     * This class has to be implemented by every plugin.
     * Additionally, the plugin module is required to have a register_plugin
     * function which returns a PluginInfo struct.
     * The plugin_type field has to be the type of your plugin class derived
     * from this class.
     */
 G_GNUC_NO_INLINE static GType
gala_plugin_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (GalaPluginClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gala_plugin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GalaPlugin), 0, (GInstanceInitFunc) gala_plugin_instance_init, NULL };
	GType gala_plugin_type_id;
	gala_plugin_type_id = g_type_register_static (G_TYPE_OBJECT, "GalaPlugin", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	GalaPlugin_private_offset = g_type_add_instance_private (gala_plugin_type_id, sizeof (GalaPluginPrivate));
	return gala_plugin_type_id;
}

GType
gala_plugin_get_type (void)
{
	static gsize gala_plugin_type_id__once = 0;
	if (g_once_init_enter (&gala_plugin_type_id__once)) {
		GType gala_plugin_type_id;
		gala_plugin_type_id = gala_plugin_get_type_once ();
		g_once_init_leave (&gala_plugin_type_id__once, gala_plugin_type_id);
	}
	return gala_plugin_type_id__once;
}

static void
_vala_gala_plugin_get_property (GObject * object,
                                guint property_id,
                                GValue * value,
                                GParamSpec * pspec)
{
	GalaPlugin * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GALA_TYPE_PLUGIN, GalaPlugin);
#line 75 "../lib/Plugin.vala"
	switch (property_id) {
#line 75 "../lib/Plugin.vala"
		case GALA_PLUGIN_FREEZE_TRACK_PROPERTY:
#line 75 "../lib/Plugin.vala"
		g_value_set_boolean (value, gala_plugin_get_freeze_track (self));
#line 75 "../lib/Plugin.vala"
		break;
#line 1034 "Plugin.c"
		default:
#line 75 "../lib/Plugin.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 75 "../lib/Plugin.vala"
		break;
#line 1040 "Plugin.c"
	}
}

static void
_vala_gala_plugin_set_property (GObject * object,
                                guint property_id,
                                const GValue * value,
                                GParamSpec * pspec)
{
	GalaPlugin * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GALA_TYPE_PLUGIN, GalaPlugin);
#line 75 "../lib/Plugin.vala"
	switch (property_id) {
#line 75 "../lib/Plugin.vala"
		case GALA_PLUGIN_FREEZE_TRACK_PROPERTY:
#line 75 "../lib/Plugin.vala"
		gala_plugin_set_freeze_track (self, g_value_get_boolean (value));
#line 75 "../lib/Plugin.vala"
		break;
#line 1060 "Plugin.c"
		default:
#line 75 "../lib/Plugin.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 75 "../lib/Plugin.vala"
		break;
#line 1066 "Plugin.c"
	}
}

